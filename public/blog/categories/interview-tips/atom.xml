<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: interview tips | Nicolás Hock Isaza]]></title>
  <link href="http://blog.nhocki.com/blog/categories/interview-tips/atom.xml" rel="self"/>
  <link href="http://blog.nhocki.com/"/>
  <updated>2013-03-07T21:33:07-05:00</updated>
  <id>http://blog.nhocki.com/</id>
  <author>
    <name><![CDATA[Nicolás Hock Isaza]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tower of Hanoi with a stack]]></title>
    <link href="http://blog.nhocki.com/2013/02/05/tower-of-hanoi-with-a-stack/"/>
    <updated>2013-02-05T14:37:00-05:00</updated>
    <id>http://blog.nhocki.com/2013/02/05/tower-of-hanoi-with-a-stack</id>
    <content type="html"><![CDATA[<p>I&#39;ve recently subscribed to <a href="http://codingforinterviews.com/">Coding for Interviews</a>
and received my first email today. The content is great and you should join. 
Even if you&#39;re not looking for a job, it&#39;s a short read with nice topics to 
refresh your memory.</p>

<p><a href="http://us2.campaign-archive2.com/?u=cadc6c448cd083a0aeed7f864&amp;id=c550bc59d5&amp;e=5694567579">Today&#39;s assignment</a> was with stacks. I&#39;ve used stacks to
<a href="http://blog.nhocki.com/2012/12/27/reverse-a-list-in-o-n/">reverse a list in O(n)</a>
but today&#39;s challenge was to solve the <a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">Tower of Hanoi</a> problem without
recursion.</p>

<p>Here&#39;s my solution:</p>

<p><div><script src='https://gist.github.com/4716874.js?file='></script>
<noscript><pre><code>Hanoi = Struct.new(:disk, :source, :dest, :spare)

def move(hanoi)
  &quot;Move #{hanoi.disk.abs} from #{hanoi.source} to #{hanoi.dest}&quot;
end

class Stack
  def initialize
    @data = []
  end

  def push(hanoi)
    @data.unshift(hanoi)
  end

  def pop
    @data.shift
  end

  def peek
    @data.first
  end

  def empty?
    @data.empty?
  end
end


# Resolve the Tower of Hanoi problem with a Stack. You can't use recursion
# in it's traditional way, but adding everything to a stack works the same.
#
# Notice you have to invert the order of the calls to the recursive function
# since the stack is **Last In - First Out**.
def stacker hanoi
  stack = Stack.new
  stack.push(hanoi)

  until stack.empty? do
    hanoi = stack.pop

    if hanoi.disk &lt;= 1
      puts move(hanoi)
    else
      left  = Hanoi.new(hanoi.disk - 1, hanoi.source, hanoi.spare, hanoi.dest)
      right = Hanoi.new(hanoi.disk - 1, hanoi.spare, hanoi.dest, hanoi.source)
      hanoi.disk = -hanoi.disk # force printing it next time it appears
      stack.push right
      stack.push hanoi
      stack.push left
    end
  end
end


# Resolve the Tower of Hanoi problem with recursion.
def recursive hanoi
  if hanoi.disk == 1
    puts move(hanoi)
  else
    left  = Hanoi.new(hanoi.disk - 1, hanoi.source, hanoi.spare, hanoi.dest)
    right = Hanoi.new(hanoi.disk - 1, hanoi.spare, hanoi.dest, hanoi.source)
    recursive(left)
    puts move(hanoi)
    recursive(right)
  end
end

h = Hanoi.new(3, 'A', 'B', 'C')

recursive(h)
puts &quot;\n\n&quot;
stacker(h)
</code></pre></noscript></div>
</p>

<p>There&#39;s another iterative solution but I haven&#39;t implemented it. So, if you did
or have some other way to solve this, I&#39;d love to know on
<a href="https://twitter.com/nhocki">Twitter @nhocki</a></p>
]]></content>
  </entry>
  
</feed>
